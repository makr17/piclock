#!/usr/bin/env python

from Adafruit_7Segment import SevenSegment
from datetime import datetime, timedelta
from fysom import Fysom
import httplib
import json
import logging
import os
from pytz import timezone
from quick2wire.gpio import pins, In, Out, Rising, Falling, Both, PullDown
from quick2wire.selector import Selector, Timer
import string
from suds.client import Client
import time
from xml.dom.minidom import parseString

def load_config():
    f = open(os.environ["HOME"]+"/clock.config.json")
    config = json.load(f)
    f.close()
    return config

def get_geoip():
    conn = httplib.HTTPConnection('www.telize.com')
    conn.request('GET', '/geoip')
    res = conn.getresponse()
    body = res.read()
    geo = json.loads(body)
    if geo.get('latitude') and geo.get('longitude'):
        config['geo'] = geo

def highTemps(geo):
    product = noaa.factory.create("ns0:productType")
    unit = noaa.factory.create("ns0:unitType")
    format = noaa.factory.create("ns0:formatType")
    wparams = noaa.factory.create("ns0:weatherParametersType")
    # request max temps (highs)
    wparams.maxt = 1

    # pull forecast for today and tomorrow (forward one day)
    begin = datetime.now()
    end = begin + timedelta(days=1)

    xml = noaa.service.NDFDgen(
        config["geo"]["latitude"],
        config["geo"]["longitude"],
        product["glance"],
        begin,
        end,
        unit["e"],
        wparams
    )
    dom = parseString(xml)
    nodes = dom.getElementsByTagName('temperature')[0].getElementsByTagName('value')
    temps = [int(x.childNodes[0].nodeValue) for x in nodes]
    return temps

logging.basicConfig(level=logging.INFO)

segment = SevenSegment(address=0x70)
brightness = 5
segment.disp.setBrightness(brightness)
wsdl = "http://graphical.weather.gov/xml/DWMLgen/wsdl/ndfdXML.wsdl"
noaa = Client(wsdl)
config = load_config()
get_geoip()
utc = timezone('UTC')
print 'timezone='+config['geo']['timezone']
local = timezone(config['geo']['timezone'])
temps = highTemps(config['geo'])
print 'lat='+str(config['geo']['latitude'])
print 'lon='+str(config['geo']['longitude'])

allchars = string.maketrans('','')
nodigs = allchars.translate(allchars, string.digits)

def local_time():
    now = utc.localize(datetime.utcnow())
    localtime = now.astimezone(local)
    return localtime

# chunk a list of numbers into a list of lists of digits
# since we need to write out to the display one digit at a time
def digits(length, *numbers):
    digs = [];
    for num in numbers:
        chunks = [int(x) for x in ' '.join(str(num)).split()]
        # pad with leading zero to meet requested length
        if len(chunks) < length:
            chunks.insert(0,0)
        digs.append(chunks)
    return digs

def current_time_display():
    now = local_time()
    pm = False
    hour = now.hour
    if hour >= 12:
        pm = True
    hour = hour % 12
    if hour == 0:
        hour = 12
    digs = digits(2, hour, now.minute)
    segment.setColon(1)
    segment.disp.clear()
    if digs[0][0] > 0:
        segment.writeDigit(0, digs[0][0])
    segment.writeDigit(1, digs[0][1])
    segment.writeDigit(3, digs[1][0])
    segment.writeDigit(4, digs[1][1], dot=pm)

def onclock(e):
    current_time_display()

def get_temp(e):
    global temps
    temps = highTemps(config['geo'])

def ontemp(e):
    now = local_time()
    # today's forecast until noon, then tomorrow after
    idx = 0
    if now.hour >= 12:
        idx = 1
    temp = temps[idx]
    digs = digits(3, temp)
    segment.disp.clear()
    segment.setColon(0)
    if digs[0][0] > 0:
        segment.writeDigit(0, digs[0][0])
    segment.writeDigit(1, digs[0][1])
    segment.writeDigit(3, digs[0][2])
    segment.writeDigit(4, 15)

def ontimeout(e):
    print 'timeout'

def onalarm(e):
    name = e.dst
    idx = int(name.translate(allchars, nodigs))
    alarm = config['alarms'][idx]
    digs = digits(2, alarm['hour'], alarm['minute'])
    segment.writeDigit(0, digs[0][0])
    segment.writeDigit(1, digs[0][1])
    segment.writeDigit(3, digs[1][0])
    segment.writeDigit(4, digs[1][1])
    segment.setColon(1)

def play_alarm():
    print('play_alarm not yet implemented')

def update_alarm():
    print('update_alarm not yet implemented')

def calc_offset():
    now = local_time()
    h = now.hour
    m = (now.minute + 1)%60
    if m == 0:
        h = h + 1
    zero = now.replace(hour = h, minute = m, second = 0, microsecond = 0)
    delta = zero - now

    interval = delta.total_seconds()
    if interval < 0:
        time.sleep(1)
        interval = calc_offset()
    return interval

state_config = {
    'events': [
        {'name': 'startup', 'src': 'none', 'dst': 'clock'},
        {'name': 'mode', 'src': 'clock', 'dst': 'temp'},
        {'name': 'mode', 'src': 'temp', 'dst': 'clock'},
        {'name': 'timeout', 'src': '*', 'dst': 'clock'}
    ],
    'callbacks': {
        'onclock': onclock,
        'ontemp': ontemp,
        'ontimeout': ontimeout
    }
}
src = 'temp'
for index, alarm in enumerate(config['alarms']):
    dst = 'alarm'+str(index)
    state_config['events'].append({'name': 'mode', 'src': src, 'dst': dst})
    state_config['callbacks']['on'+dst] = onalarm
    src = dst
if state_config['callbacks']['onalarm0']:
    del state_config['events'][2]
    state_config['events'].append({'name': 'mode', 'src': src, 'dst': 'clock'})

# setup the statemachine
fsm = Fysom(state_config)

def update_display():
    if fsm.current == 'clock':
        current_time_display()

# should transition to clock state and call update_display
fsm.startup()

# setup the event loop to monitor timers and buttons
selector = Selector()
mode_button = pins.pin(0, direction=In, interrupt=Rising, pull=PullDown)
set_button  = pins.pin(1, direction=In, interrupt=Rising, pull=PullDown)

minute_timer = Timer(interval=60, offset=calc_offset())
minute_timer.start()
alarm_timer = Timer(offset=1)
temp_timer = Timer(interval=3600, offset=3600)
temp_timer.start

with selector, mode_button, set_button, minute_timer, alarm_timer, temp_timer:
    selector.add(mode_button)
    selector.add(set_button)
    selector.add(minute_timer)
    selector.add(alarm_timer)
    selector.add(temp_timer)

    # go back to init state
    fsm.timeout()

    while True:
        selector.wait()

        if selector.ready == minute_timer:
            minute_timer.wait()
            update_display()
        elif selector.ready == alarm_timer:
            print 'alarm timer tripped'
            alarm_timer.wait()
            # TODO: set a timeout for the next alarm in the queue
            play_alarm()
        elif selector.ready == temp_timer:
            get_temp()
        elif selector.ready == mode_button:
            if mode_button.value == 1:
                fsm.mode()
                time.sleep(0.2)
        elif selector.ready == set_button:
            if set_button.value == 1:
                if fsm.current == 'clock':
                    brightness = (brightness + 1)%16
                    segment.disp.setBrightness(brightness)
                    update_display()
                elif fsm.current == 'alarm1':
                    update_alarm(1)
                elif fsm.current == 'alarm2':
                    update_alarm(2)
